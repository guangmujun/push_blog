---
title: 交通学习之共享单车数据处理
date: 2022-02-08
permalink: /2022/交通学习/traffic-learning-share-bike-data-analysis.html
tags:
 - 交通学习
 - 共享单车
categories:
 - 交通学习
---

## EX1共享单车停车需求识别

### 共享单车订单数据

字段：

- 单车ID
- 经纬度
- 时间
- 锁状态

特征：

- 采样间隔长
- 不同单车公司数据质量不同
- 开关锁位置相对准确，但路径信息不准确

样例：

<img src="https://my-imags.oss-cn-shanghai.aliyuncs.com/pic/202202081443023.png" style="zoom:50%;" />



### 共享单车停车需求识别

目的：

- 识别出一天内某一时间共享单车的停放情况

步骤：

1、读取数据重命名数据的列

2、根据车辆ID与时间对数据进行排序

3、数据列整体上移一行

4、保留同一辆车的记录、保留ID、经纬度、停车开始时间和停车结束时间

5、设定时间戳，提取这一时间的停车需求

### 代码与结果

代码：

识别出`2020/12/25 8:00:00`这个时间点，处于停车状态的共享单车

```python
import pandas as pd
#读取数据
data_bike = pd.read_csv(r'data_bike.csv',header = None)
#重命名数据的列
data_bike.columns = ['BIKE_ID','LATITUDE','LONGITUDE','LOCK_STATUS','DATA_TIME']
#对数据根据车辆与时间排序
data_bike = data_bike.sort_values(by = ['BIKE_ID','DATA_TIME'])
#数据列整体上移一行，赋值给新的列
data_bike['BIKE_ID1'] = data_bike['BIKE_ID'].shift(-1)
for i in ['BIKE_ID', 'LATITUDE', 'LONGITUDE', 'LOCK_STATUS', 'DATA_TIME']:
    data_bike[i+'1'] = data_bike[i].shift(-1)
#去除非同一车辆的记录
data_bike = data_bike[data_bike['BIKE_ID'] == data_bike['BIKE_ID1']]
#提取其中的停车信息
data_bike = data_bike[data_bike['LOCK_STATUS'] == 1]
#保留有用的列
data_bike = data_bike[['BIKE_ID','LATITUDE','LONGITUDE','DATA_TIME','DATA_TIME1']]
#取某一时间
timstamp = '2020/12/25 8:00:00'
#提取这一时间的停车需求
parking_points = data_bike[(data_bike['DATA_TIME']<=timstamp)&(data_bike['DATA_TIME1']>=timstamp)]
```

结果：

其中`DATA_TIME`是开始停放时间，`DATA_TIME1`是停放结束时间。

<img src="https://my-imags.oss-cn-shanghai.aliyuncs.com/pic/202202081558131.png" style="zoom:50%;" />

## EX2电子栅栏数据生成地理空间图形

### 电子栅栏数据

字段：

- 栅栏ID
- 经纬度坐标

样例：

<img src="https://my-imags.oss-cn-shanghai.aliyuncs.com/pic/202202081559636.png" style="zoom:50%;" />

### 空间要素处理

工具：

- GeoPandas库，在数据表上进行地理信息处理的操作
- GeoPandas生成的表叫做GeoDataFrame，其中有列尾`geometry`，里面包含`Point\LineString\Polygon`等图形要素

步骤：

1、读取数据

2、将文本字符串坐标转换为list【**exec操作：将字符串转换为代码**】

3、使用shapely将点元素转换为面元素

4、遍历数据，为数据添加一列geometry，将df转化为gdf

5、存储地理空间数据，为对数据进行空间操作做准备

### 代码与结果

代码：

通过exec语法将字符串转化为列表并赋值给变量

可将gdf数据存储为shp格式，也可存储为json格式

```python
import geopandas as gpd
from shapely.geometry import Polygon
import pandas as pd
#读取电子栅栏数据
data_fence = pd.read_csv(r'data_fence.csv')
#为电子栅栏生成多边形几何信息
geometry = []
for i in range(len(data_fence)):
    exec('points = ['+data_fence['FENCE_LOC'].iloc[i]+']')
    geometry.append(Polygon(points))
data_fence['geometry'] = geometry
#将数据表转换为geodataframe
data_fence = gpd.GeoDataFrame(data_fence)
data_fence = data_fence.drop('FENCE_LOC',axis = 1)

#存储数据，shp格式,输出一个温文件夹
data_fence.to_file(r'data_fence')

#存储数据，geojson格式
data_fence.to_file(r'data_fence.json',driver = 'GeoJSON',encoding = 'utf-8')
```

结果：

<img src="https://my-imags.oss-cn-shanghai.aliyuncs.com/pic/202202081601068.png" style="zoom:50%;" />

可视化：

- geojson可视化 http://geojson.io/
- shp可视化 http://blog.giscafer.com/mapshaper-plus/
- GeoDataFrame可直接使用plot函数

## EX3停车需求与电子栅栏地图匹配

### 空间连接确定栅栏内的停车点

步骤：

1、停车需求数据转化为geopandas【gpd.points_from_xy】

2、对停车数据与电子栅栏数据进行空间连接【gpd.sjoin】

补充：

使用`?gpd.sjoin`即可得到语法说明

```python
geopandas.sjoin(
	left_df,             # GeoDataFrame,左表
  right_df,            # GeoDataFrame,右表
  how='inner',         # 连接方式
  op='intersects',     # 用于设定拓扑判断对规则，intersects相交，contains包含，within与contains相反
  lsuffix='left',
  rsuffix='right',
)
```

代码：

```python
#将停车需求转化为geopandas，方便后续匹配
parking_points = gpd.GeoDataFrame(parking_points)
parking_points['geometry'] = gpd.points_from_xy(parking_points['LONGITUDE'],parking_points['LONGITUDE'])

#空间连接：提取在栅栏内的停车需求
parking_points = gpd.sjoin(parking_points,data_fence,how = 'left')

#保存在栅栏内的停车需求
a = parking_points[-parking_points['FENCE_ID'].isnull()]

#保存在栅栏外的停车需求
b = parking_points[parking_points['FENCE_ID'].isnull()]
```

效果：

停在栅栏范围内的单车

<img src="https://my-imags.oss-cn-shanghai.aliyuncs.com/pic/202202081556942.png" style="zoom:50%;" />

### KDTree进行栅栏外单车分析

目的：

- 栅栏外的停车点匹配到最近的栅栏，并计算距离

步骤：

1、提取电子栅栏边界

2、用KDTree匹配停车点到最近的电子栅栏

3、matplotlib可视化

**KDTree**补充：

- **KDTree**建立空间索引,划分二维空间建立空间索引,看看点位于哪个空间
- 评价
  - 可以找到一个点附近的点或者面
  - 不一定是最近，可在较小的范围内进一步搜索
- 原理
  - KDTree，K-Dimensional Tree
  - 算法复杂度从`O(N)`提升到`O(log(N))`

<img src="https://my-imags.oss-cn-shanghai.aliyuncs.com/pic/202202081621056.png" style="zoom:50%;" />

<img src="https://my-imags.oss-cn-shanghai.aliyuncs.com/pic/202202081621643.png" style="zoom:50%;" />

- 实现

```python
#定义函数，用cKDTree匹配点与点，点与线
import numpy as np
from scipy.spatial import cKDTree
import itertools
from operator import itemgetter
def ckdnearest_point(gdA, gdB):
    '''
    输入两个geodataframe，gdfA、gdfB均为点，该方法会为gdfA表连接上gdfB中最近的点，并添加距离字段dsit
    '''
    #提取gdA中的所有点要素
    nA = np.array(list(gdA.geometry.apply(lambda x: (x.x, x.y))))
    #提取gdB中的所有点要素
    nB = np.array(list(gdB.geometry.apply(lambda x: (x.x, x.y))))
    #为gdB表的点建立KDTree
    btree = cKDTree(nB)
    #在gdB的KDTree中查询gdA的点,dist为距离,idx为gdB中离gdA最近的坐标点
    dist, idx = btree.query(nA, k=1)
    #构建匹配的结果
    gdf = pd.concat(
        [gdA.reset_index(drop=True), gdB.loc[idx, gdB.columns != 'geometry'].reset_index(drop=True),
         pd.Series(dist, name='dist')], axis=1)
    return gdf
def ckdnearest_line(gdfA, gdfB):
    '''
    输入两个geodataframe，其中gdfA为点，gdfB为线，该方法会为gdfA表连接上gdfB中最近的线，并添加距离字段dsit
    '''
    #提取gdA中的所有点要素
    A = np.concatenate(
        [np.array(geom.coords) for geom in gdfA.geometry.to_list()])
    #把gdfB的几何坐标提取到B，此时B为一个大list中包含多个小list，每个小list代表一个几何图形，小list中为坐标
    #B=[[[要素1坐标1],[要素1坐标2],...],[[要素2坐标1],[要素2坐标2],...]]
    B = [np.array(geom.coords) for geom in gdfB.geometry.to_list()]
    #B_ix代表B中的每个坐标点分别属于B中的哪个几何图形
    B_ix = tuple(itertools.chain.from_iterable(
        [itertools.repeat(i, x) for i, x in enumerate(list(map(len, B)))]))
    #把B表展开，B=[[要素1坐标1],[要素1坐标2],...,[要素2坐标2],[要素2坐标2],...]
    B = np.concatenate(B)
    #为B表建立KDTree
    ckd_tree = cKDTree(B)
    #在B的KDTree中查询A的点,dist为距离,idx为B中离A最近的坐标点
    dist, idx = ckd_tree.query(A, k=1)
    #由坐标点对应到几何要素
    idx = itemgetter(*idx)(B_ix)
    #构建匹配的结果
    gdf = pd.concat(
        [gdfA.reset_index(drop=True), gdfB.loc[idx, gdfB.columns != 'geometry'].reset_index(drop=True),
         pd.Series(dist, name='dist').reset_index(drop=True)], axis=1)
    return gdf

```

代码：

```python
#提取每个电子栅栏的边界
data_fence_boundary = data_fence.copy()
data_fence_boundary['geometry'] = data_fence_boundary.boundary

#尝试绘制前几个栅栏
data_fence_boundary.iloc[:5].plot()
```

<img src="https://my-imags.oss-cn-shanghai.aliyuncs.com/pic/202202081626743.png" style="zoom:50%;" />

```python
#把栅栏外的停车点匹配到最近栅栏
b = ckdnearest_line(b, data_fence_boundary)

#整理数据然后合并
a = a[['BIKE_ID', 'LATITUDE', 'LONGITUDE', 'DATA_TIME', 'DATA_TIME1',
       'geometry','FENCE_ID']]
b.columns = ['BIKE_ID', 'LATITUDE', 'LONGITUDE', 'DATA_TIME', 'DATA_TIME1',
       'geometry', 'index_right', 'FENCE_ID1', 'FENCE_ID', 'dist']
b = b[['BIKE_ID', 'LATITUDE', 'LONGITUDE', 'DATA_TIME', 'DATA_TIME1',
       'geometry','FENCE_ID', 'dist']]
parking_points = pd.concat([a,b])
```



```python
# 统计每个栅栏停车需求数
parking_points['FENCE_ID'].value_counts()

#可视化
import matplotlib.pyplot as plt
#创建图
fig = plt.figure(1,(10,10),dpi = 200)
ax = plt.subplot(111)

#选择某一栅栏
fence = '蔡岭路 _R_2'
#绘制栅栏内外的停车需求
parking_points[parking_points['FENCE_ID']==fence].plot(ax = ax)
parking_points[(parking_points['FENCE_ID']==fence)&(parking_points['dist'].isnull())].plot(ax = ax,color = 'r')
#绘制栅栏
data_fence[data_fence['FENCE_ID']==fence].plot(ax = ax,color = 'g',alpha=0.3)

#显示图
plt.show()
```

<img src="https://my-imags.oss-cn-shanghai.aliyuncs.com/pic/202202081639314.png" style="zoom:50%;" />















